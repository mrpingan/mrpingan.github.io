<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://uxt2ec.coding-pages.com/</id>
    <title>Ping&apos;s Home</title>
    <updated>2020-08-12T02:52:21.044Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://uxt2ec.coding-pages.com/"/>
    <link rel="self" href="https://uxt2ec.coding-pages.com/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://uxt2ec.coding-pages.com/images/avatar.png</logo>
    <icon>https://uxt2ec.coding-pages.com/favicon.ico</icon>
    <rights>All rights reserved 2020, Ping&apos;s Home</rights>
    <entry>
        <title type="html"><![CDATA[ubuntu导入CA证书]]></title>
        <id>https://uxt2ec.coding-pages.com/post/ubuntu-dao-ru-ca-zheng-shu/</id>
        <link href="https://uxt2ec.coding-pages.com/post/ubuntu-dao-ru-ca-zheng-shu/">
        </link>
        <updated>2020-08-11T14:49:29.000Z</updated>
        <content type="html"><![CDATA[<h2 id="导入证书">导入证书</h2>
<pre><code class="language-bash">cp 证书路径.crt /usr/local/share/ca-certificates
update-ca-certificates
</code></pre>
<p><strong>update-ca-certificates命令将PEM格式的根证书内容附加到/etc/ssl/certs/ca-certificates.crt ，而/etc/ssl/certs/ca-certificates.crt 包含了系统自带的各种可信根证书</strong></p>
<h2 id="删除证书">删除证书</h2>
<pre><code class="language-bash">rm -f /usr/local/share/ca-certificates/证书名称.crt
update-ca-certificates
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[brook科学上网]]></title>
        <id>https://uxt2ec.coding-pages.com/post/brook-ke-xue-shang-wang/</id>
        <link href="https://uxt2ec.coding-pages.com/post/brook-ke-xue-shang-wang/">
        </link>
        <updated>2020-07-02T07:08:16.000Z</updated>
        <content type="html"><![CDATA[<p>ss使用很容易被封，可以使用brook。brook使用简单，开源而且支持多个平台<br>
https://talks.txthinking.com/slides/brook.slide</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[jenkins pipeline暂停]]></title>
        <id>https://uxt2ec.coding-pages.com/post/jenkins-pipeline-zan-ting/</id>
        <link href="https://uxt2ec.coding-pages.com/post/jenkins-pipeline-zan-ting/">
        </link>
        <updated>2020-07-01T07:43:34.000Z</updated>
        <content type="html"><![CDATA[<p>pipeline中可以进行暂停操作，这在进行高风险操作的时候特别有用。比如，有两台服务器，部署了一台，需要先测试观察日志，就可以在部署这台的stage后加入暂停stage。</p>
<pre><code class="language-groovy">stage('input') {
		input {
				message &quot;Should we continue?&quot;
				ok &quot;Yes, we should.&quot;
		}
		steps {
				echo &quot;continue...&quot;
		}
}
</code></pre>
<p>当加入这段groovy脚本后，jenkins执行到这儿就会需要用户手动去点击&quot;Yes, we should&quot;。这样，脚本才会继续跑下去。<br>
input还有其他参数可以选择，比如只能指定的人点击，还可以输入参数。<br>
另外一个例子：</p>
<pre><code class="language-groovy">pipeline {
    agent any
    stages {
        stage('Example') {
            input {
                message &quot;Should we continue?&quot;
                ok &quot;Yes, we should.&quot;
                submitter &quot;admin,anthony&quot;
                parameters {
                    string(name: 'PERSON', defaultValue: 'Mr Anthony', description: 'Who should I say hello to?')
                }
            }
            steps {
                echo &quot;Hello, ${PERSON}, nice to meet you.&quot;
            }
        }
    }
}
</code></pre>
<p>上面代码的意思：运行之前，需要提供input，而且这个input提交，只有admin和anthony这两个用户可以，其他用户提交会失败。把这段代码拷贝到一个pipeline类型的job设置的pipeline tab页面。</p>
</hr>
参考文档：https://blog.csdn.net/u011541946/article/details/83589588]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Django]]></title>
        <id>https://uxt2ec.coding-pages.com/post/django/</id>
        <link href="https://uxt2ec.coding-pages.com/post/django/">
        </link>
        <updated>2020-04-20T16:22:22.000Z</updated>
        <content type="html"><![CDATA[<h1 id="django数据模型字段">django数据模型字段</h1>
<table>
<thead>
<tr>
<th>字段名</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>auto_now_add</td>
<td>添加对象的时间，更新对象不会变动</td>
</tr>
<tr>
<td>auto_now</td>
<td>字段保存时会自动保存当前时间</td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[linux命令]]></title>
        <id>https://uxt2ec.coding-pages.com/post/linux-ming-ling/</id>
        <link href="https://uxt2ec.coding-pages.com/post/linux-ming-ling/">
        </link>
        <updated>2020-03-26T14:50:53.000Z</updated>
        <content type="html"><![CDATA[<h1 id="io重定向">I/O重定向</h1>
<h2 id="cat往文件写内容">cat往文件写内容</h2>
<p>这个命令使用了<code>&gt;</code>表示覆盖，如果是<code>&gt;&gt;</code>则表示追加</p>
<pre><code class="language-bash">cat &gt;foo.sh &lt;&lt;EOF
print &quot;$s was here&quot; &quot;$name&quot;
EOF
</code></pre>
<p><code>foo.sh</code>显示结果如下，发现变量<code>$name</code>被解析了</p>
<pre><code class="language-bash">print &quot;%s was here&quot; &quot;&quot;
</code></pre>
<p>避免变量被解析，可以这样做，在<strong>EOF</strong>之前加了一个\</p>
<pre><code class="language-bash">cat &gt;foo.sh &lt;&lt;\EOF
print &quot;$s was here&quot; &quot;$name&quot;
EOF
</code></pre>
<p>这样变量<code>$name</code>就不会被解析了</p>
<h1 id="创建一个管道">创建一个管道</h1>
<pre><code class="language-bash">mkfifo /tmp/pipe
</code></pre>
<p>可以一个程序写，另外一个程序读</p>
<h1 id="创建一个临时文件或者目录">创建一个临时文件或者目录</h1>
<p>创建临时文件</p>
<pre><code class="language-bash">mktemp
# 指定后缀长度和dirname,X必须要为大写
mktemp /tmp/tmp-XXX
mktemp ~/tmp-XXX
</code></pre>
<p>创建临时目录</p>
<pre><code class="language-bash">mktemp -d 
#也可以指定后缀长度和dirname
mktemp -d /tmp/tmp.XXXX
mktemp -d ~/tmp.XXXX
</code></pre>
<h1 id="history">History</h1>
<p>从安全角度考虑，禁止<code>history</code></p>
<pre><code>ln -s /dev/null .bash_history
</code></pre>
<hr/>
<h1 id="bash">bash</h1>
<pre><code class="language-bash"># 检查语法
bash -n

# 显示详细过程
bash -x
</code></pre>
<h1 id="内部环境变量">内部环境变量</h1>
<h2 id="set">set</h2>
<h2 id="export">export</h2>
<h2 id="unset">unset</h2>
<h1 id="系统变量">系统变量</h1>
<table>
<thead>
<tr>
<th>变量</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>$n</td>
<td>$1表示第一个参数，$2表示第二个参数</td>
</tr>
<tr>
<td>$#</td>
<td>表示参数的个数</td>
</tr>
<tr>
<td>$0</td>
<td>当前程序的名称</td>
</tr>
<tr>
<td>$?</td>
<td>前一个程序的返回码</td>
</tr>
<tr>
<td>$*</td>
<td>以&quot;参数1 参数2 ...&quot;形式保存所有变量</td>
</tr>
<tr>
<td>$@</td>
<td>以&quot;参数1&quot;&quot;参数2&quot;...形式保存所有变量</td>
</tr>
<tr>
<td>$$</td>
<td>本程序的PID</td>
</tr>
<tr>
<td>$!</td>
<td>上个命令</td>
</tr>
</tbody>
</table>
<h1 id="字符串处理">字符串处理</h1>
<h2 id="左删除">左删除</h2>
<p>从左边往右边匹配</p>
<pre><code class="language-bash"># 删除第一个匹配fo以及左边
MYVAR=foodforthought.jpg
echo ${MYVAR#*fo}
#结果
odforthought.jpg

# 删除最后一个匹配fo以及左边
MYVAR=foodforthought.jpg
echo ${MYVAR##*fo}
# 结果
rthought.jpg
</code></pre>
<h2 id="右删除">右删除</h2>
<p>从右边往左边匹配</p>
<pre><code class="language-bash">#删除第一个匹配fo及其右边的字符
MYVAR=foodforthought.jpg
echo ${MYVAR%fo*}
#结果
food

#从右往左删除最后一个匹配fo及其右边的字符
MYVAR=anfoodforthought.jpg
echo ${MYVAR%%fo*}
#结果
an
</code></pre>
<h2 id="字符串截取">字符串截取</h2>
<pre><code class="language-bash">#从n1到n2截取字符串
${varible:n1:n2}

MYVAR1=cowbody
echo ${MYVAR1:0:3}
#结果
cow

echo ${MYVAR1: -3}
#结果
ody
</code></pre>
<h1 id="数组">数组</h1>
<h2 id="创建数组">创建数组</h2>
<pre><code class="language-bash">arr=(hello world)
#或者
arr[0]=hello
arr[1]=world

echo ${arr[0] arr[1]}
</code></pre>
<table>
<thead>
<tr>
<th>表达式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>${arr[*]}</td>
<td>列出数组中所有的值</td>
</tr>
<tr>
<td>${!arr[*]}</td>
<td>数组中所有的索引</td>
</tr>
<tr>
<td>${#arr[*]}</td>
<td>数组中元素个数</td>
</tr>
<tr>
<td>${#arr[0]}</td>
<td>数组中索引0的元素长度</td>
</tr>
</tbody>
</table>
<h1 id="eval">eval</h1>
<pre><code class="language-bash">i=5
a_5=250
echo \$&quot;a_$i&quot;
#结果
250

neo=&quot;Neo Chen&quot;
name=neo
eval &quot;echo \$$name&quot;
#结果
Neo Chen

</code></pre>
<h1 id="for">for</h1>
<pre><code class="language-bash">#示例1：
for ((i=1;i&lt;5;i++))
do
		echo $i
		sleep $i
done
#示例2:
for i in {1..5}
do
	echo $i
	sleep $i
done
#示例3:
for i in `seq 1 10`;do echo $i;done
#示例4:
for i in {1..10} {20..30} {40..50};do mkdir $i;done
</code></pre>
<h1 id="find">find</h1>
<pre><code>find pathname -options [-print -exec -ok ...]
-print：将匹配到的文件输出到标准输出
-exec：find命令对匹配的文件执行给出的shell命令。相应的形式为'command {} ;' ,注意{}和；有一个空格
-ok：和-exec的用法相同，只是以一个更安全的模式来执行给出的shell命令，只执行每个命令之前都会给出提示。

find . -type f -mtime +5 -ok rm { } \;

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ansible执行速度优化]]></title>
        <id>https://uxt2ec.coding-pages.com/post/ansible-zhi-xing-su-du-you-hua/</id>
        <link href="https://uxt2ec.coding-pages.com/post/ansible-zhi-xing-su-du-you-hua/">
        </link>
        <updated>2020-03-24T16:17:10.000Z</updated>
        <content type="html"><![CDATA[<p>ansible没有agent，采用ssh来通讯，在机器数量达到一个量级的时候，执行流程会变得很慢。这儿提供一些优化思路</p>
<h1 id="优化一facts">优化一：facts</h1>
<p>默认情况下，ansible会收集远程机器的facts变量，playbook中可以使用这些变量。如果没有使用facts中的值，也可以关闭这个选项gather_facts: False，提高执行效率<br>
也可以开启facts缓存，ansible支持json文件缓存，配置如下:</p>
<pre><code class="language-ini"># /etc/ansible/ansible.cfg
gathering = smart
fact_caching_timeout = 86400
fact_caching = jsonfile
fact_caching_connection = /dev/shm/ansible_fact_cache
</code></pre>
<h1 id="优化二openssl长连接">优化二：openssl长连接</h1>
<p>openssl高版本支持多路复用，也就是开启一个长连接，开启后，会通过一个socket文件与远程设备保存一个长连接</p>
<pre><code>#调整ssh配置
ssh_args = -C -o ControlMaster=auto -o ControlPersist=5d
</code></pre>
<h1 id="优化三pipeline">优化三：pipeline</h1>
<p>开启pipeline后，ansible不再将本地生成好的python脚本发送到远程机器，而是直接复用ssh回话进行，这将大大提高整个执行效率<br>
当然，开启pipeline，需要被控机器/etc/sudoers文件编辑当前ansible ssh用户的配置为requiretty,否则在执行ansible的时候会报错</p>
<pre><code>pipelining = True
</code></pre>
<h1 id="优化四开启accelerate模式">优化四：开启accelerate模式</h1>
<p>开启accelerate后，ansible会在远程机器上启动一个守护进程，控制端会通过这个守护进程进行通讯。<br>
需要注意的是，如果开启此模式，则需要控制端和被控端都需要安装<code>python-keyczar</code>安装包。<br>
定义参数：</p>
<pre><code>[accelerate]
accelerate_port = 5099
accelerate_timeout = 30
accelerate_connect_timeout = 5.0
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[自动化运维工具比较]]></title>
        <id>https://uxt2ec.coding-pages.com/post/zi-dong-hua-yun-wei-gong-ju-bi-jiao/</id>
        <link href="https://uxt2ec.coding-pages.com/post/zi-dong-hua-yun-wei-gong-ju-bi-jiao/">
        </link>
        <updated>2020-03-24T15:40:46.000Z</updated>
        <content type="html"><![CDATA[<table>
<thead>
<tr>
<th>名称</th>
<th>puppt</th>
<th>saltstack</th>
<th>ansible</th>
</tr>
</thead>
<tbody>
<tr>
<td>开发语言</td>
<td>Ruby</td>
<td>Python</td>
<td>Python</td>
</tr>
<tr>
<td>客户端</td>
<td>有</td>
<td>有</td>
<td>无</td>
</tr>
<tr>
<td>二次开发</td>
<td>不支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>通信加密</td>
<td>标准ssl协议</td>
<td>AES加密</td>
<td>OpenSSH</td>
</tr>
<tr>
<td>配置文件格式</td>
<td>Ruby语法</td>
<td>yaml</td>
<td>yaml</td>
</tr>
<tr>
<td>webUI</td>
<td>提供</td>
<td>提供</td>
<td>提供（商业版）</td>
</tr>
</tbody>
</table>
<p>ansible缺点：</p>
<ul>
<li>对管理节点为windows有待加强</li>
<li>需导入资源清单</li>
<li>执行效率地（可能是ssh服务慢，可以通过优化ssh连接速度和使用ansible加速模块提高效率）</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[nginx防止爬虫爬页面]]></title>
        <id>https://uxt2ec.coding-pages.com/post/nginx-fang-zhi-pa-chong-pa-ye-mian/</id>
        <link href="https://uxt2ec.coding-pages.com/post/nginx-fang-zhi-pa-chong-pa-ye-mian/">
        </link>
        <updated>2020-03-24T15:33:27.000Z</updated>
        <content type="html"><![CDATA[<h1 id="方法一">方法一</h1>
<p>修改nginx，匹配到爬虫的ua，直接返回403</p>
<pre><code class="language-nginx">server { 
	listen 80; 
	server_name 127.0.0.1; 
	#添加如下内容即可防止爬虫
	if ($http_user_agent ~* &quot;qihoobot|Baiduspider|Googlebot|Googlebot-Mobile|Googlebot-Image|Mediapartners-Google|Adsbot-Google|Feedfetcher-Google|Yahoo! Slurp|Yahoo! Slurp China|YoudaoBot|Sosospider|Sogou spider|Sogou web spider|MSNBot|ia_archiver|Tomato Bot&quot;) 
	{
	return 403; 
	}
} 
</code></pre>
<h1 id="方法二">方法二</h1>
<p>网站下增加<strong>Robots.txt</strong>，放在站点根目录<br>
在http://tool.chinaz.com/robots/站点可以针对现在的搜索引擎按照想要的规则生成robots.txt文件。<br>
robots.txt是搜索引擎中访问网站的时候要查看的第一个文件。robots.txt文件告诉蜘蛛程序在服务器上什么文件是可以被查看的。<br>
当一个搜索蜘蛛访问一个站点时，它会首先检查该站点根目录下是否存在robots.txt，如果存在，搜索机器人就会按照该文件中的内容来确定访问的范围；如果该文件不存在，所有的搜索蜘蛛将能够访问网站上所有没有被口令保护的页面。百度官方建议，仅当您的网站包含不希望被搜索引擎收录的内容时，才需要使用robots.txt文件。如果您希望搜索引擎收录网站上所有内容，请勿建立robots.txt文件。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[iptables查看数据包传输过程]]></title>
        <id>https://uxt2ec.coding-pages.com/post/iptables-cha-kan-shu-ju-bao-chuan-shu-guo-cheng/</id>
        <link href="https://uxt2ec.coding-pages.com/post/iptables-cha-kan-shu-ju-bao-chuan-shu-guo-cheng/">
        </link>
        <updated>2020-03-22T02:11:02.000Z</updated>
        <content type="html"><![CDATA[<p>docker容器和宿主机在通过docker0网桥通信时，linux内核netfilter也参与其中，如果使用的iptables，可通过开启iptables的TRACE功能，查看数据包的传输过程。</p>
<pre><code class="language-linux"># 在宿主机上执行
iptables -t raw -A OUTPUT -p icmp -j TRACE
iptables -t raw -A PREROUTING -p icmp -j TRACE
</code></pre>
<p>通过上述设置，就可以在<code>/var/log/syslog</code>里看到数据包传输的过程了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ubuntu 安装es]]></title>
        <id>https://uxt2ec.coding-pages.com/post/ubuntu-an-zhuang-es/</id>
        <link href="https://uxt2ec.coding-pages.com/post/ubuntu-an-zhuang-es/">
        </link>
        <updated>2020-03-10T03:47:08.000Z</updated>
        <content type="html"><![CDATA[<p>使用dpkg安装es的时候，发现<code>/etc/elasticserach</code>目录下一直没有配置文件。重新安装也是这样。</p>
<pre><code># 可以尝试全部清除配置文件
dpkg -P package_name
</code></pre>
<p>然后重新安装，顺利完成</p>
]]></content>
    </entry>
</feed>