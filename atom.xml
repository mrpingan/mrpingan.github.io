<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://mrpingan.github.io</id>
    <title>Ping&apos;s Home</title>
    <updated>2020-03-27T06:13:05.763Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://mrpingan.github.io"/>
    <link rel="self" href="https://mrpingan.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://mrpingan.github.io/images/avatar.png</logo>
    <icon>https://mrpingan.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Ping&apos;s Home</rights>
    <entry>
        <title type="html"><![CDATA[linux命令]]></title>
        <id>https://mrpingan.github.io/post/linux-ming-ling</id>
        <link href="https://mrpingan.github.io/post/linux-ming-ling">
        </link>
        <updated>2020-03-26T14:50:53.000Z</updated>
        <content type="html"><![CDATA[<p>[toc]</p>
<h1 id="io重定向">I/O重定向</h1>
<h2 id="cat往文件写内容">cat往文件写内容</h2>
<p>这个命令使用了<code>&gt;</code>表示覆盖，如果是<code>&gt;&gt;</code>则表示追加</p>
<pre><code class="language-bash">cat &gt;foo.sh &lt;&lt;EOF
print &quot;$s was here&quot; &quot;$name&quot;
EOF
</code></pre>
<p><code>foo.sh</code>显示结果如下，发现变量<code>$name</code>被解析了</p>
<pre><code class="language-bash">print &quot;%s was here&quot; &quot;&quot;
</code></pre>
<p>避免变量被解析，可以这样做，在<strong>EOF</strong>之前加了一个\</p>
<pre><code class="language-bash">cat &gt;foo.sh &lt;&lt;\EOF
print &quot;$s was here&quot; &quot;$name&quot;
EOF
</code></pre>
<p>这样变量<code>$name</code>就不会被解析了</p>
<h1 id="创建一个管道">创建一个管道</h1>
<pre><code class="language-bash">mkfifo /tmp/pipe
</code></pre>
<p>可以一个程序写，另外一个程序读</p>
<h1 id="创建一个临时文件或者目录">创建一个临时文件或者目录</h1>
<p>创建临时文件</p>
<pre><code class="language-bash">mktemp
# 指定后缀长度和dirname,X必须要为大写
mktemp /tmp/tmp-XXX
mktemp ~/tmp-XXX
</code></pre>
<p>创建临时目录</p>
<pre><code class="language-bash">mktemp -d 
#也可以指定后缀长度和dirname
mktemp -d /tmp/tmp.XXXX
mktemp -d ~/tmp.XXXX
</code></pre>
<h1 id="history">History</h1>
<p>从安全角度考虑，禁止<code>history</code></p>
<pre><code>ln -s /dev/null .bash_history
</code></pre>
<hr/>
<h1 id="bash">bash</h1>
<pre><code class="language-bash"># 检查语法
bash -n

# 显示详细过程
bash -x
</code></pre>
<h1 id="内部环境变量">内部环境变量</h1>
<h2 id="set">set</h2>
<h2 id="export">export</h2>
<h2 id="unset">unset</h2>
<h1 id="系统变量">系统变量</h1>
<table>
<thead>
<tr>
<th>变量</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>$n</td>
<td>$1表示第一个参数，$2表示第二个参数</td>
</tr>
<tr>
<td>$#</td>
<td>表示参数的个数</td>
</tr>
<tr>
<td>$0</td>
<td>当前程序的名称</td>
</tr>
<tr>
<td>$?</td>
<td>前一个程序的返回码</td>
</tr>
<tr>
<td>$*</td>
<td>以&quot;参数1 参数2 ...&quot;形式保存所有变量</td>
</tr>
<tr>
<td>$@</td>
<td>以&quot;参数1&quot;&quot;参数2&quot;...形式保存所有变量</td>
</tr>
<tr>
<td>$$</td>
<td>本程序的PID</td>
</tr>
<tr>
<td>$!</td>
<td>上个命令</td>
</tr>
</tbody>
</table>
<h1 id="字符串处理">字符串处理</h1>
<h2 id="左删除">左删除</h2>
<p>从左边往右边匹配</p>
<pre><code class="language-bash"># 删除第一个匹配fo以及左边
MYVAR=foodforthought.jpg
echo ${MYVAR#*fo}
#结果
odforthought.jpg

# 删除最后一个匹配fo以及左边
MYVAR=foodforthought.jpg
echo ${MYVAR##*fo}
# 结果
rthought.jpg
</code></pre>
<h2 id="右删除">右删除</h2>
<p>从右边往左边匹配</p>
<pre><code class="language-bash">#删除第一个匹配fo及其右边的字符
MYVAR=foodforthought.jpg
echo ${MYVAR%fo*}
#结果
food

#从右往左删除最后一个匹配fo及其右边的字符
MYVAR=anfoodforthought.jpg
echo ${MYVAR%%fo*}
#结果
an
</code></pre>
<h2 id="字符串截取">字符串截取</h2>
<pre><code class="language-bash">#从n1到n2截取字符串
${varible:n1:n2}

MYVAR1=cowbody
echo ${MYVAR1:0:3}
#结果
cow

echo ${MYVAR1: -3}
#结果
ody
</code></pre>
<h1 id="数组">数组</h1>
<h2 id="创建数组">创建数组</h2>
<pre><code class="language-bash">arr=(hello world)
#或者
arr[0]=hello
arr[1]=world

echo ${arr[0] arr[1]}
</code></pre>
<table>
<thead>
<tr>
<th>表达式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>${arr[*]}</td>
<td>列出数组中所有的值</td>
</tr>
<tr>
<td>${!arr[*]}</td>
<td>数组中所有的索引</td>
</tr>
<tr>
<td>${#arr[*]}</td>
<td>数组中元素个数</td>
</tr>
<tr>
<td>${#arr[0]}</td>
<td>数组中索引0的元素长度</td>
</tr>
</tbody>
</table>
<h1 id="eval">eval</h1>
<pre><code class="language-bash">i=5
a_5=250
echo \$&quot;a_$i&quot;
#结果
250

neo=&quot;Neo Chen&quot;
name=neo
eval &quot;echo \$$name&quot;
#结果
Neo Chen

</code></pre>
<h1 id="for">for</h1>
<pre><code class="language-bash">#示例1：
for ((i=1;i&lt;5;i++))
do
		echo $i
		sleep $i
done
#示例2:
for i in {1..5}
do
	echo $i
	sleep $i
done
#示例3:
for i in `seq 1 10`;do echo $i;done
#示例4:
for i in {1..10} {20..30} {40..50};do mkdir $i;done
</code></pre>
<h1 id="find">find</h1>
<pre><code>find pathname -options [-print -exec -ok ...]
-print：将匹配到的文件输出到标准输出
-exec：find命令对匹配的文件执行给出的shell命令。相应的形式为'command {} ;' ,注意{}和；有一个空格
-ok：和-exec的用法相同，只是以一个更安全的模式来执行给出的shell命令，只执行每个命令之前都会给出提示。

find . -type f -mtime +5 -exec rm { } ;

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ansible执行速度优化]]></title>
        <id>https://mrpingan.github.io/post/ansible-zhi-xing-su-du-you-hua</id>
        <link href="https://mrpingan.github.io/post/ansible-zhi-xing-su-du-you-hua">
        </link>
        <updated>2020-03-24T16:17:10.000Z</updated>
        <content type="html"><![CDATA[<p>ansible没有agent，采用ssh来通讯，在机器数量达到一个量级的时候，执行流程会变得很慢。这儿提供一些优化思路</p>
<h1 id="优化一facts">优化一：facts</h1>
<p>默认情况下，ansible会收集远程机器的facts变量，playbook中可以使用这些变量。如果没有使用facts中的值，也可以关闭这个选项gather_facts: False，提高执行效率<br>
也可以开启facts缓存，ansible支持json文件缓存，配置如下:</p>
<pre><code class="language-ini"># /etc/ansible/ansible.cfg
gathering = smart
fact_caching_timeout = 86400
fact_caching = jsonfile
fact_caching_connection = /dev/shm/ansible_fact_cache
</code></pre>
<h1 id="优化二openssl长连接">优化二：openssl长连接</h1>
<p>openssl高版本支持多路复用，也就是开启一个长连接，开启后，会通过一个socket文件与远程设备保存一个长连接</p>
<pre><code>#调整ssh配置
ssh_args = -C -o ControlMaster=auto -o ControlPersist=5d
</code></pre>
<h1 id="优化三pipeline">优化三：pipeline</h1>
<p>开启pipeline后，ansible不再将本地生成好的python脚本发送到远程机器，而是直接复用ssh回话进行，这将大大提高整个执行效率<br>
当然，开启pipeline，需要被控机器/etc/sudoers文件编辑当前ansible ssh用户的配置为requiretty,否则在执行ansible的时候会报错</p>
<pre><code>pipelining = True
</code></pre>
<h1 id="优化四开启accelerate模式">优化四：开启accelerate模式</h1>
<p>开启accelerate后，ansible会在远程机器上启动一个守护进程，控制端会通过这个守护进程进行通讯。<br>
需要注意的是，如果开启此模式，则需要控制端和被控端都需要安装<code>python-keyczar</code>安装包。<br>
定义参数：</p>
<pre><code>[accelerate]
accelerate_port = 5099
accelerate_timeout = 30
accelerate_connect_timeout = 5.0
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[自动化运维工具比较]]></title>
        <id>https://mrpingan.github.io/post/zi-dong-hua-yun-wei-gong-ju-bi-jiao</id>
        <link href="https://mrpingan.github.io/post/zi-dong-hua-yun-wei-gong-ju-bi-jiao">
        </link>
        <updated>2020-03-24T15:40:46.000Z</updated>
        <content type="html"><![CDATA[<table>
<thead>
<tr>
<th>名称</th>
<th>puppt</th>
<th>saltstack</th>
<th>ansible</th>
</tr>
</thead>
<tbody>
<tr>
<td>开发语言</td>
<td>Ruby</td>
<td>Python</td>
<td>Python</td>
</tr>
<tr>
<td>客户端</td>
<td>有</td>
<td>有</td>
<td>无</td>
</tr>
<tr>
<td>二次开发</td>
<td>不支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>通信加密</td>
<td>标准ssl协议</td>
<td>AES加密</td>
<td>OpenSSH</td>
</tr>
<tr>
<td>配置文件格式</td>
<td>Ruby语法</td>
<td>yaml</td>
<td>yaml</td>
</tr>
<tr>
<td>webUI</td>
<td>提供</td>
<td>提供</td>
<td>提供（商业版）</td>
</tr>
</tbody>
</table>
<p>ansible缺点：</p>
<ul>
<li>对管理节点为windows有待加强</li>
<li>需导入资源清单</li>
<li>执行效率地（可能是ssh服务慢，可以通过优化ssh连接速度和使用ansible加速模块提高效率）</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[nginx防止爬虫爬页面]]></title>
        <id>https://mrpingan.github.io/post/nginx-fang-zhi-pa-chong-pa-ye-mian</id>
        <link href="https://mrpingan.github.io/post/nginx-fang-zhi-pa-chong-pa-ye-mian">
        </link>
        <updated>2020-03-24T15:33:27.000Z</updated>
        <content type="html"><![CDATA[<h1 id="方法一">方法一</h1>
<p>修改nginx，匹配到爬虫的ua，直接返回403</p>
<pre><code class="language-nginx">server { 
	listen 80; 
	server_name 127.0.0.1; 
	#添加如下内容即可防止爬虫
	if ($http_user_agent ~* &quot;qihoobot|Baiduspider|Googlebot|Googlebot-Mobile|Googlebot-Image|Mediapartners-Google|Adsbot-Google|Feedfetcher-Google|Yahoo! Slurp|Yahoo! Slurp China|YoudaoBot|Sosospider|Sogou spider|Sogou web spider|MSNBot|ia_archiver|Tomato Bot&quot;) 
	{
	return 403; 
	}
} 
</code></pre>
<h1 id="方法二">方法二</h1>
<p>网站下增加<strong>Robots.txt</strong>，放在站点根目录<br>
在http://tool.chinaz.com/robots/站点可以针对现在的搜索引擎按照想要的规则生成robots.txt文件。<br>
robots.txt是搜索引擎中访问网站的时候要查看的第一个文件。robots.txt文件告诉蜘蛛程序在服务器上什么文件是可以被查看的。<br>
当一个搜索蜘蛛访问一个站点时，它会首先检查该站点根目录下是否存在robots.txt，如果存在，搜索机器人就会按照该文件中的内容来确定访问的范围；如果该文件不存在，所有的搜索蜘蛛将能够访问网站上所有没有被口令保护的页面。百度官方建议，仅当您的网站包含不希望被搜索引擎收录的内容时，才需要使用robots.txt文件。如果您希望搜索引擎收录网站上所有内容，请勿建立robots.txt文件。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[iptables查看数据包传输过程]]></title>
        <id>https://mrpingan.github.io/post/iptables-cha-kan-shu-ju-bao-chuan-shu-guo-cheng</id>
        <link href="https://mrpingan.github.io/post/iptables-cha-kan-shu-ju-bao-chuan-shu-guo-cheng">
        </link>
        <updated>2020-03-22T02:11:02.000Z</updated>
        <content type="html"><![CDATA[<p>docker容器和宿主机在通过docker0网桥通信时，linux内核netfilter也参与其中，如果使用的iptables，可通过开启iptables的TRACE功能，查看数据包的传输过程。</p>
<pre><code class="language-linux"># 在宿主机上执行
iptables -t raw -A OUTPUT -p icmp -j TRACE
iptables -t raw -A PREROUTING -p icmp -j TRACE
</code></pre>
<p>通过上述设置，就可以在<code>/var/log/syslog</code>里看到数据包传输的过程了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ubuntu 安装es]]></title>
        <id>https://mrpingan.github.io/post/ubuntu-an-zhuang-es</id>
        <link href="https://mrpingan.github.io/post/ubuntu-an-zhuang-es">
        </link>
        <updated>2020-03-10T03:47:08.000Z</updated>
        <content type="html"><![CDATA[<p>使用dpkg安装es的时候，发现<code>/etc/elasticserach</code>目录下一直没有配置文件。重新安装也是这样。</p>
<pre><code># 可以尝试全部清除配置文件
dpkg -P package_name
</code></pre>
<p>然后重新安装，顺利完成</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[apollo笔记]]></title>
        <id>https://mrpingan.github.io/post/apollo-bi-ji</id>
        <link href="https://mrpingan.github.io/post/apollo-bi-ji">
        </link>
        <updated>2020-02-12T07:02:44.000Z</updated>
        <content type="html"><![CDATA[<p>apollo是携程开源的配置中心组件。可以将配置集中放置，并在配置变更后推送给应用，实现修改配置无需重启服务，而且配置有版本控制，可回滚。</p>
<h1 id="为什么要引入apollo">为什么要引入Apollo</h1>
<p>1、接入apollo可以让配置集中放置，配置热更新，服务无需重启。<br>
2、接入apollo更安全。配置如果放在服务源码中，如果服务源码泄露，配置也会随着泄露。<br>
参考文章：http://beckjin.com/2019/07/14/apollo-distributed/<br>
https://www.infoq.cn/article/ctrip-apollo-configuration-center-architecture</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[rabbitmq集群部分文档]]></title>
        <id>https://mrpingan.github.io/post/rabbitmq-ji-qun-bu-fen-wen-dang</id>
        <link href="https://mrpingan.github.io/post/rabbitmq-ji-qun-bu-fen-wen-dang">
        </link>
        <updated>2020-02-11T14:52:51.000Z</updated>
        <content type="html"><![CDATA[<p>一个RabbitMQ集群是一个或者多个rabbitmq单机节点逻辑上的组。每一个成员共享users,virtual hosts,queues,exchanges,bindings,runtime parameters和其他分布式的状态。</p>
<h1 id="集群发现">集群发现</h1>
<p>一个RabbitMQ可以通过多种方式构建</p>
<ul>
<li>在配置文件中指明节点</li>
<li>通过基于DNS解析为IP</li>
<li>使用AWS(EC2) instance discovery（需要通过插件）</li>
<li>通过基于consul discovery（需要通过插件）</li>
<li>通过etcd（需要通过插件）</li>
<li>通过<code>rabbitmqctl</code>手动指定</li>
</ul>
<h2 id="节点名">节点名</h2>
<p>RabbitMQ节点通过节点名来识别。一个rabbitmq节点包括两部分。一个前缀（通常是rabbit）和主机名。比如<code>rabbit@node1.messaging.svc.local</code><br>
集群中的节点名必须唯一。如果在一个服务器上运行了多了rabbitmq节点，则这些节点必须要使用不同的前缀，比如<code>rabbit1@hostname</code>和<code>rabbit2@hostname</code> 。<br>
在集群中，节点通过节点名来相互辨别和通信。这意味着每一个节点的hostname都可以正常解析。rabbitmq命令行工具也使用节点名来辨别节点。<br>
当一个节点启动时，将会检查是否这个节点已经注册，节点名也可以通过<code>RABBITMQ_NODENAME</code>环境变量设置。如果这个变量没有声明，将会使用<code>rabbit@hostname</code>的方式。<br>
如果系统使用了FQDNs，RabbitMQ节点和命令行工具必须要配置使用长节点名称。可以使用<code>RABBITMQ_USE_LONGNAME</code>环境变量为<code>true</code>,在命令行工具中，除了可以配置<code>RABBITMQ_USE_LONGNAME</code>环境变量或者<code>--longnames</code>参数。</p>
<h2 id="集群发现前提">集群发现前提</h2>
<h3 id="主机名可解析">主机名可解析</h3>
<p>可以在<code>/etc/hosts</code>中配置主机名来解析主机名。有一些场景，修改hosts文件是不被容许的。erlang虚拟机可以配置使用其他的方法来解析主机名，如配置DNS服务器，指定一个本地的文件，一个非标准hosts文件</p>
<h3 id="端口可达">端口可达</h3>
<p>RabbitMQ节点绑定到TCP端口来接受客户端和命令行工具的连接。一些进程和工具如<code>selinux</code>可能会阻止RabbitMQ绑定端口。当绑定端口失败时，RabbitMQ节点启动会失败。<br>
请保证节点之间的下列端口可访问：</p>
<ul>
<li>4369 a helper discovery daemon used by RabbitMQ nodes and CLI tools</li>
<li>5672,5671 AMQP 0-9-1 和1.0 客户端连接端口</li>
<li>25672 节点之间通信端口</li>
<li>15672 HTTP API客户端，管理后台启动端口</li>
<li>61613, 61614  STOMP clients without and with TLS (only if the STOMP plugin is enabled)</li>
<li>1883, 8883: (MQTT clients without and with TLS, if the MQTT plugin is enabled</li>
<li>15674: STOMP-over-WebSockets clients (only if the Web STOMP plugin is enabled)</li>
<li>15675: MQTT-over-WebSockets clients (only if the Web MQTT plugin is enabled)</li>
<li>15692: Prometheus metrics (only if the Prometheus plugin is enabled)</li>
</ul>
<h2 id="集群节点">集群节点</h2>
<p>一些分布式系统有leader和follower节点角色，在RabbitMQ中没有这些角色。所有的节点都是一样的，没有特别的节点。<br>
命令行工具或者HTTP API访问任何一个节点得到的数据都是一致的。<br>
RabbitMQ节点和命令行工具（如rabbitmqctl）使用一个cookie来决定是否他们可以相互通信。两个节点只有cookie一致才能正常通信。cookie是一段随机字母数字字符串，存储在本地文件。这个文件的权限也要控制，如设置为400或者600。<br>
如果这个文件不存在，Erlang虚拟机将会在rabbitmq启动的时候创建一个。<br>
cookie文件路径<br>
linux、MacOS、*BSD：/var/lib/rabbitmq/.erlang.cookie</p>
<h3 id="节点数量">节点数量</h3>
<p>集群中的数量最好为奇数个：1，3，5等等<br>
两个节点的集群极不推荐</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Django-rest-framework]]></title>
        <id>https://mrpingan.github.io/post/django-rest-framework</id>
        <link href="https://mrpingan.github.io/post/django-rest-framework">
        </link>
        <updated>2020-01-08T13:48:44.000Z</updated>
        <content type="html"><![CDATA[<p>1、浏览器api界面没有Login按钮</p>
<pre><code class="language-python">urlpatterns = [
    path('^api-auth/',include('rest_framework.urls',namespace=&quot;rest_framework_auth&quot;))
]
</code></pre>
<p>需要在<code>urls.py</code>中配置这一条路由，就可以看到登录按钮了<br>
<img src="https://mrpingan.github.io/post-images/1578491545380.png" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[好文一览]]></title>
        <id>https://mrpingan.github.io/post/hao-wen-yi-lan</id>
        <link href="https://mrpingan.github.io/post/hao-wen-yi-lan">
        </link>
        <updated>2019-12-27T14:15:42.000Z</updated>
        <content type="html"><![CDATA[<p>django源码解读：<br>
http://www.ziawang.com/article/302/#<br>
http://www.ziawang.com/blog/django/<br>
http://www.ziawang.com/article/169/</p>
<p>erp开源项目：<br>
https://sourcegraph.com/github.com/zhuinfo/Django-ERP/-/blob/plugin/wfusers.py</p>
<p>站点：<br>
http://devopstarter.info/page/9/</p>
]]></content>
    </entry>
</feed>